// Code generated by MockGen. DO NOT EDIT.
// Source: internal/microservices/auth/proto/auth_grpc.pb.go

// Package mock_proto is a generated GoMock package.
package mock_proto

import (
	context "context"
	proto "harmonica/internal/microservices/auth/proto"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockAuthorizationClient is a mock of AuthorizationClient interface.
type MockAuthorizationClient struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizationClientMockRecorder
}

// MockAuthorizationClientMockRecorder is the mock recorder for MockAuthorizationClient.
type MockAuthorizationClientMockRecorder struct {
	mock *MockAuthorizationClient
}

// NewMockAuthorizationClient creates a new mock instance.
func NewMockAuthorizationClient(ctrl *gomock.Controller) *MockAuthorizationClient {
	mock := &MockAuthorizationClient{ctrl: ctrl}
	mock.recorder = &MockAuthorizationClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizationClient) EXPECT() *MockAuthorizationClientMockRecorder {
	return m.recorder
}

// CheckSession mocks base method.
func (m *MockAuthorizationClient) CheckSession(ctx context.Context, in *proto.CheckSessionRequest, opts ...grpc.CallOption) (*proto.CheckSessionResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckSession", varargs...)
	ret0, _ := ret[0].(*proto.CheckSessionResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckSession indicates an expected call of CheckSession.
func (mr *MockAuthorizationClientMockRecorder) CheckSession(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckSession", reflect.TypeOf((*MockAuthorizationClient)(nil).CheckSession), varargs...)
}

// IsAuth mocks base method.
func (m *MockAuthorizationClient) IsAuth(ctx context.Context, in *proto.Empty, opts ...grpc.CallOption) (*proto.IsAuthResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IsAuth", varargs...)
	ret0, _ := ret[0].(*proto.IsAuthResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAuth indicates an expected call of IsAuth.
func (mr *MockAuthorizationClientMockRecorder) IsAuth(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAuth", reflect.TypeOf((*MockAuthorizationClient)(nil).IsAuth), varargs...)
}

// Login mocks base method.
func (m *MockAuthorizationClient) Login(ctx context.Context, in *proto.LoginUserRequest, opts ...grpc.CallOption) (*proto.LoginUserResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Login", varargs...)
	ret0, _ := ret[0].(*proto.LoginUserResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Login indicates an expected call of Login.
func (mr *MockAuthorizationClientMockRecorder) Login(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthorizationClient)(nil).Login), varargs...)
}

// Logout mocks base method.
func (m *MockAuthorizationClient) Logout(ctx context.Context, in *proto.LogoutRequest, opts ...grpc.CallOption) (*proto.LogoutResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Logout", varargs...)
	ret0, _ := ret[0].(*proto.LogoutResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Logout indicates an expected call of Logout.
func (mr *MockAuthorizationClientMockRecorder) Logout(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockAuthorizationClient)(nil).Logout), varargs...)
}

// MockAuthorizationServer is a mock of AuthorizationServer interface.
type MockAuthorizationServer struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizationServerMockRecorder
}

// MockAuthorizationServerMockRecorder is the mock recorder for MockAuthorizationServer.
type MockAuthorizationServerMockRecorder struct {
	mock *MockAuthorizationServer
}

// NewMockAuthorizationServer creates a new mock instance.
func NewMockAuthorizationServer(ctrl *gomock.Controller) *MockAuthorizationServer {
	mock := &MockAuthorizationServer{ctrl: ctrl}
	mock.recorder = &MockAuthorizationServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizationServer) EXPECT() *MockAuthorizationServerMockRecorder {
	return m.recorder
}

// CheckSession mocks base method.
func (m *MockAuthorizationServer) CheckSession(arg0 context.Context, arg1 *proto.CheckSessionRequest) (*proto.CheckSessionResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckSession", arg0, arg1)
	ret0, _ := ret[0].(*proto.CheckSessionResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckSession indicates an expected call of CheckSession.
func (mr *MockAuthorizationServerMockRecorder) CheckSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckSession", reflect.TypeOf((*MockAuthorizationServer)(nil).CheckSession), arg0, arg1)
}

// IsAuth mocks base method.
func (m *MockAuthorizationServer) IsAuth(arg0 context.Context, arg1 *proto.Empty) (*proto.IsAuthResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAuth", arg0, arg1)
	ret0, _ := ret[0].(*proto.IsAuthResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAuth indicates an expected call of IsAuth.
func (mr *MockAuthorizationServerMockRecorder) IsAuth(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAuth", reflect.TypeOf((*MockAuthorizationServer)(nil).IsAuth), arg0, arg1)
}

// Login mocks base method.
func (m *MockAuthorizationServer) Login(arg0 context.Context, arg1 *proto.LoginUserRequest) (*proto.LoginUserResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Login", arg0, arg1)
	ret0, _ := ret[0].(*proto.LoginUserResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Login indicates an expected call of Login.
func (mr *MockAuthorizationServerMockRecorder) Login(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthorizationServer)(nil).Login), arg0, arg1)
}

// Logout mocks base method.
func (m *MockAuthorizationServer) Logout(arg0 context.Context, arg1 *proto.LogoutRequest) (*proto.LogoutResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Logout", arg0, arg1)
	ret0, _ := ret[0].(*proto.LogoutResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Logout indicates an expected call of Logout.
func (mr *MockAuthorizationServerMockRecorder) Logout(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockAuthorizationServer)(nil).Logout), arg0, arg1)
}

// mustEmbedUnimplementedAuthorizationServer mocks base method.
func (m *MockAuthorizationServer) mustEmbedUnimplementedAuthorizationServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedAuthorizationServer")
}

// mustEmbedUnimplementedAuthorizationServer indicates an expected call of mustEmbedUnimplementedAuthorizationServer.
func (mr *MockAuthorizationServerMockRecorder) mustEmbedUnimplementedAuthorizationServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedAuthorizationServer", reflect.TypeOf((*MockAuthorizationServer)(nil).mustEmbedUnimplementedAuthorizationServer))
}

// MockUnsafeAuthorizationServer is a mock of UnsafeAuthorizationServer interface.
type MockUnsafeAuthorizationServer struct {
	ctrl     *gomock.Controller
	recorder *MockUnsafeAuthorizationServerMockRecorder
}

// MockUnsafeAuthorizationServerMockRecorder is the mock recorder for MockUnsafeAuthorizationServer.
type MockUnsafeAuthorizationServerMockRecorder struct {
	mock *MockUnsafeAuthorizationServer
}

// NewMockUnsafeAuthorizationServer creates a new mock instance.
func NewMockUnsafeAuthorizationServer(ctrl *gomock.Controller) *MockUnsafeAuthorizationServer {
	mock := &MockUnsafeAuthorizationServer{ctrl: ctrl}
	mock.recorder = &MockUnsafeAuthorizationServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeAuthorizationServer) EXPECT() *MockUnsafeAuthorizationServerMockRecorder {
	return m.recorder
}

// mustEmbedUnimplementedAuthorizationServer mocks base method.
func (m *MockUnsafeAuthorizationServer) mustEmbedUnimplementedAuthorizationServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedAuthorizationServer")
}

// mustEmbedUnimplementedAuthorizationServer indicates an expected call of mustEmbedUnimplementedAuthorizationServer.
func (mr *MockUnsafeAuthorizationServerMockRecorder) mustEmbedUnimplementedAuthorizationServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedAuthorizationServer", reflect.TypeOf((*MockUnsafeAuthorizationServer)(nil).mustEmbedUnimplementedAuthorizationServer))
}
